// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: EchoModel/address.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Address_TaxCodeOrIdCardTypeEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// 未知类型
  case unknown // = 0

  /// 巴西 CPF(personal order)
  case cpf // = 1

  /// 巴西 CNPJ(company order)
  case cnpj // = 2

  /// 阿根廷 CUIL (personal order)
  case cuil // = 3

  /// 阿根廷 CUIT (company order)
  case cuit // = 4

  /// 泰国 Personal ID number(personal order)
  case personalIDNumber // = 5

  /// 泰国 VAT ID number(company order)
  case vatIDNumber // = 6

  ///墨西哥 CURP
  case curp // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .cpf
    case 2: self = .cnpj
    case 3: self = .cuil
    case 4: self = .cuit
    case 5: self = .personalIDNumber
    case 6: self = .vatIDNumber
    case 7: self = .curp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .cpf: return 1
    case .cnpj: return 2
    case .cuil: return 3
    case .cuit: return 4
    case .personalIDNumber: return 5
    case .vatIDNumber: return 6
    case .curp: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Address_TaxCodeOrIdCardTypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Address_TaxCodeOrIdCardTypeEnum] = [
    .unknown,
    .cpf,
    .cnpj,
    .cuil,
    .cuit,
    .personalIDNumber,
    .vatIDNumber,
    .curp,
  ]
}

#endif  // swift(>=4.2)

public struct Address_DeleteAddressReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///地址簿主键id
  public var id: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_DeleteAddressResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  public var data: Common_Empty {
    get {return _data ?? Common_Empty()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
  fileprivate var _data: Common_Empty? = nil
}

public struct Address_GetShippingAddressListForCheckoutReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// shipTo国家id
  public var shipToCountryID: Int32 = 0

  /// checkout页面上，用户选择的地址id
  public var userSelectedAddressID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_GetShippingAddressListForCheckoutFakeResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接口返回状态对象
  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  ///地址列表对象
  public var data: [Address_Address] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
}

public struct Address_Address {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///地址簿主键id
  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  ///地址所属userId
  public var customersID: Int32 {
    get {return _storage._customersID}
    set {_uniqueStorage()._customersID = newValue}
  }

  public var firstName: String {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  public var lastName: String {
    get {return _storage._lastName}
    set {_uniqueStorage()._lastName = newValue}
  }

  ///电话号码(带区号) 66-777777777
  public var areaCodePhoneNumber: String {
    get {return _storage._areaCodePhoneNumber}
    set {_uniqueStorage()._areaCodePhoneNumber = newValue}
  }

  ///电话号码(不带区号) 7777777
  public var phoneNumber: String {
    get {return _storage._phoneNumber}
    set {_uniqueStorage()._phoneNumber = newValue}
  }

  ///电话号码2(带区号) 66-777777777
  public var areaCodePhoneNumber2: String {
    get {return _storage._areaCodePhoneNumber2}
    set {_uniqueStorage()._areaCodePhoneNumber2 = newValue}
  }

  ///电话号码2(不带区号) 7777777
  public var phoneNumber2: String {
    get {return _storage._phoneNumber2}
    set {_uniqueStorage()._phoneNumber2 = newValue}
  }

  ///该地址所属国家对象信息
  public var country: Common_Country {
    get {return _storage._country ?? Common_Country()}
    set {_uniqueStorage()._country = newValue}
  }
  /// Returns true if `country` has been explicitly set.
  public var hasCountry: Bool {return _storage._country != nil}
  /// Clears the value of `country`. Subsequent reads from it will return its default value.
  public mutating func clearCountry() {_uniqueStorage()._country = nil}

  /// 州/省 信息对象
  public var stateProvinceRegion: Address_StateProvinceRegion {
    get {return _storage._stateProvinceRegion ?? Address_StateProvinceRegion()}
    set {_uniqueStorage()._stateProvinceRegion = newValue}
  }
  /// Returns true if `stateProvinceRegion` has been explicitly set.
  public var hasStateProvinceRegion: Bool {return _storage._stateProvinceRegion != nil}
  /// Clears the value of `stateProvinceRegion`. Subsequent reads from it will return its default value.
  public mutating func clearStateProvinceRegion() {_uniqueStorage()._stateProvinceRegion = nil}

  ///邮编
  public var postCode: String {
    get {return _storage._postCode}
    set {_uniqueStorage()._postCode = newValue}
  }

  public var city: Address_City {
    get {return _storage._city ?? Address_City()}
    set {_uniqueStorage()._city = newValue}
  }
  /// Returns true if `city` has been explicitly set.
  public var hasCity: Bool {return _storage._city != nil}
  /// Clears the value of `city`. Subsequent reads from it will return its default value.
  public mutating func clearCity() {_uniqueStorage()._city = nil}

  /// 地址1,德国street
  public var addressLine1: String {
    get {return _storage._addressLine1}
    set {_uniqueStorage()._addressLine1 = newValue}
  }

  /// 地址2
  public var addressLine2: String {
    get {return _storage._addressLine2}
    set {_uniqueStorage()._addressLine2 = newValue}
  }

  /// 是否默认推荐地址
  public var recommend: Bool {
    get {return _storage._recommend}
    set {_uniqueStorage()._recommend = newValue}
  }

  /// 是否可用
  public var available: Bool {
    get {return _storage._available}
    set {_uniqueStorage()._available = newValue}
  }

  /// 是否为账单地址
  public var billAddress: Bool {
    get {return _storage._billAddress}
    set {_uniqueStorage()._billAddress = newValue}
  }

  /// 税号/身份证 类型   当国家为: 巴西/阿根廷/泰国 时, 才会有税号/身份证
  public var taxCodeOrIDCardTypeEnum: Address_TaxCodeOrIdCardTypeEnum {
    get {return _storage._taxCodeOrIDCardTypeEnum}
    set {_uniqueStorage()._taxCodeOrIDCardTypeEnum = newValue}
  }

  /// 税号/身份证
  public var taxCodeOrIDCard: String {
    get {return _storage._taxCodeOrIDCard}
    set {_uniqueStorage()._taxCodeOrIDCard = newValue}
  }

  /// 地址扩展信息, 里面包含 邮箱 等字段
  public var addressExt: Address_AddressExt {
    get {return _storage._addressExt ?? Address_AddressExt()}
    set {_uniqueStorage()._addressExt = newValue}
  }
  /// Returns true if `addressExt` has been explicitly set.
  public var hasAddressExt: Bool {return _storage._addressExt != nil}
  /// Clears the value of `addressExt`. Subsequent reads from it will return its default value.
  public mutating func clearAddressExt() {_uniqueStorage()._addressExt = nil}

  ///收集号码是否已经被收集
  public var phoneNumberCollected: Bool {
    get {return _storage._phoneNumberCollected}
    set {_uniqueStorage()._phoneNumberCollected = newValue}
  }

  ///地址校验ERROR信息
  public var shippingAddressErrors: [String] {
    get {return _storage._shippingAddressErrors}
    set {_uniqueStorage()._shippingAddressErrors = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Address_AddressExt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///地址扩展信息主键id
  public var id: Int64 = 0

  /// 地址邮箱  当该地址是账单地址时，该邮箱则为 账单邮箱
  public var email: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_GetAddressListForAddressBookReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户id
  public var userID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_GetAddressListForAddressBookFakeResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接口返回状态对象
  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  ///地址列表对象
  public var data: [Address_Address] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
}

public struct Address_GetAddressDetailReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 地址主键id
  public var id: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_GetAddressDetailFakeResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接口返回状态对象
  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  /// 地址详情对象
  public var data: Address_Address {
    get {return _data ?? Address_Address()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
  fileprivate var _data: Address_Address? = nil
}

public struct Address_GetBillingAddressDetailReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// userId
  public var userID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_GetBillingAddressDetailFakeResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接口返回状态对象
  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  /// 地址详情对象
  public var data: Address_Address {
    get {return _data ?? Address_Address()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
  fileprivate var _data: Address_Address? = nil
}

public struct Address_AddAddressReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 地址对象
  public var address: Address_Address {
    get {return _address ?? Address_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Address_Address? = nil
}

public struct Address_AddAddressFakeResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接口返回状态对象
  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  /// 地址主键id
  public var data: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
}

public struct Address_EditAddressReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 地址对象
  public var address: Address_Address {
    get {return _address ?? Address_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Address_Address? = nil
}

public struct Address_EditAddressFakeResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接口返回状态对象
  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  /// 返回被编辑的地址主键id
  public var data: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
}

public struct Address_ModifyBillingAddressWithOrderReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 地址对象
  public var address: Address_Address {
    get {return _address ?? Address_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  /// 订单id
  public var orderID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Address_Address? = nil
}

public struct Address_ModifyBillingAddressWithOrderFakeResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接口返回状态对象
  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  /// 返回被编辑的地址主键id
  public var data: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
}

public struct Address_GetCountryCascadeInfoReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 国家id，当国家下拉框选择后，传递用户所选择的国家id
  public var countryID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_GetCountryCascadeInfoFakeResp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接口返回状态对象
  public var result: Common_Result {
    get {return _result ?? Common_Result()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  /// 国家下拉框选择后的级联对象
  public var data: Address_CountryCascadeInfo {
    get {return _data ?? Address_CountryCascadeInfo()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Common_Result? = nil
  fileprivate var _data: Address_CountryCascadeInfo? = nil
}

public struct Address_CountryCascadeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 该国家下的电话号码正则表达式 列表
  public var phoneNumberRegexList: [Address_PostCodeOrPhoneNumberRegex] = []

  /// 该国家下的邮编正则表达式 列表
  public var postCodeRegexList: [Address_PostCodeOrPhoneNumberRegex] = []

  /// 该国家下的 州/省 列表
  public var stateList: [Address_StateProvinceRegion] = []

  /// 该国家的邮编正则表达式(带模板)  目前只有 瑞典国家 才会需要模板
  public var postcodeRegexTemplate: Address_PostcodeRegexTemplate {
    get {return _postcodeRegexTemplate ?? Address_PostcodeRegexTemplate()}
    set {_postcodeRegexTemplate = newValue}
  }
  /// Returns true if `postcodeRegexTemplate` has been explicitly set.
  public var hasPostcodeRegexTemplate: Bool {return self._postcodeRegexTemplate != nil}
  /// Clears the value of `postcodeRegexTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearPostcodeRegexTemplate() {self._postcodeRegexTemplate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _postcodeRegexTemplate: Address_PostcodeRegexTemplate? = nil
}

public struct Address_PostCodeOrPhoneNumberRegex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 该正则表达式所属的国家id
  public var countryID: Int32 = 0

  /// 正则表达式id
  public var regexID: Int32 = 0

  /// 邮编或者电话号码的 正则表达式，前端用来校验格式
  public var regex: String = String()

  /// 提示语
  public var tip: String = String()

  ///是否是强检验
  public var strongCheck: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_StateProvinceRegion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 州/省 id
  public var stateID: Int32 = 0

  /// 州/省 code
  public var stateCode: String = String()

  /// 州/省 所属国家id
  public var countryID: Int32 = 0

  /// 州/省 名称
  public var stateName: String = String()

  /// 州/省 下的 cityList
  public var cityList: [Address_City] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_City {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 城市id
  public var cityID: Int32 = 0

  ///城市名称
  public var cityName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Address_PostcodeRegexTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 邮编正则表达式
  public var regex: String = String()

  /// 邮编模板示例, 如: XXX XX
  public var template: String = String()

  /// 不标准邮编正则表达式
  public var replaceRegex: String = String()

  /// 每个匹配项要替换的字符串
  public var replacement: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "address"

extension Address_TaxCodeOrIdCardTypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CPF"),
    2: .same(proto: "CNPJ"),
    3: .same(proto: "CUIL"),
    4: .same(proto: "CUIT"),
    5: .same(proto: "PERSONAL_ID_NUMBER"),
    6: .same(proto: "VAT_ID_NUMBER"),
    7: .same(proto: "CURP"),
  ]
}

extension Address_DeleteAddressReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAddressReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_DeleteAddressReq, rhs: Address_DeleteAddressReq) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_DeleteAddressResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAddressResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_DeleteAddressResp, rhs: Address_DeleteAddressResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetShippingAddressListForCheckoutReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetShippingAddressListForCheckoutReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shipToCountryId"),
    2: .same(proto: "userSelectedAddressId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.shipToCountryID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userSelectedAddressID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shipToCountryID != 0 {
      try visitor.visitSingularInt32Field(value: self.shipToCountryID, fieldNumber: 1)
    }
    if self.userSelectedAddressID != 0 {
      try visitor.visitSingularInt32Field(value: self.userSelectedAddressID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetShippingAddressListForCheckoutReq, rhs: Address_GetShippingAddressListForCheckoutReq) -> Bool {
    if lhs.shipToCountryID != rhs.shipToCountryID {return false}
    if lhs.userSelectedAddressID != rhs.userSelectedAddressID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetShippingAddressListForCheckoutFakeResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetShippingAddressListForCheckoutFakeResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetShippingAddressListForCheckoutFakeResp, rhs: Address_GetShippingAddressListForCheckoutFakeResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_Address: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Address"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "customersId"),
    3: .same(proto: "firstName"),
    4: .same(proto: "lastName"),
    5: .same(proto: "areaCodePhoneNumber"),
    6: .same(proto: "phoneNumber"),
    7: .same(proto: "areaCodePhoneNumber2"),
    8: .same(proto: "phoneNumber2"),
    9: .same(proto: "country"),
    10: .same(proto: "stateProvinceRegion"),
    11: .same(proto: "postCode"),
    12: .same(proto: "city"),
    13: .same(proto: "addressLine1"),
    14: .same(proto: "addressLine2"),
    15: .same(proto: "recommend"),
    16: .same(proto: "available"),
    17: .same(proto: "billAddress"),
    18: .same(proto: "taxCodeOrIdCardTypeEnum"),
    19: .same(proto: "taxCodeOrIdCard"),
    20: .same(proto: "addressExt"),
    21: .same(proto: "phoneNumberCollected"),
    22: .same(proto: "shippingAddressErrors"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _customersID: Int32 = 0
    var _firstName: String = String()
    var _lastName: String = String()
    var _areaCodePhoneNumber: String = String()
    var _phoneNumber: String = String()
    var _areaCodePhoneNumber2: String = String()
    var _phoneNumber2: String = String()
    var _country: Common_Country? = nil
    var _stateProvinceRegion: Address_StateProvinceRegion? = nil
    var _postCode: String = String()
    var _city: Address_City? = nil
    var _addressLine1: String = String()
    var _addressLine2: String = String()
    var _recommend: Bool = false
    var _available: Bool = false
    var _billAddress: Bool = false
    var _taxCodeOrIDCardTypeEnum: Address_TaxCodeOrIdCardTypeEnum = .unknown
    var _taxCodeOrIDCard: String = String()
    var _addressExt: Address_AddressExt? = nil
    var _phoneNumberCollected: Bool = false
    var _shippingAddressErrors: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _customersID = source._customersID
      _firstName = source._firstName
      _lastName = source._lastName
      _areaCodePhoneNumber = source._areaCodePhoneNumber
      _phoneNumber = source._phoneNumber
      _areaCodePhoneNumber2 = source._areaCodePhoneNumber2
      _phoneNumber2 = source._phoneNumber2
      _country = source._country
      _stateProvinceRegion = source._stateProvinceRegion
      _postCode = source._postCode
      _city = source._city
      _addressLine1 = source._addressLine1
      _addressLine2 = source._addressLine2
      _recommend = source._recommend
      _available = source._available
      _billAddress = source._billAddress
      _taxCodeOrIDCardTypeEnum = source._taxCodeOrIDCardTypeEnum
      _taxCodeOrIDCard = source._taxCodeOrIDCard
      _addressExt = source._addressExt
      _phoneNumberCollected = source._phoneNumberCollected
      _shippingAddressErrors = source._shippingAddressErrors
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._customersID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._areaCodePhoneNumber) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._phoneNumber) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._areaCodePhoneNumber2) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._phoneNumber2) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._country) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._stateProvinceRegion) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._postCode) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._city) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._addressLine1) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._addressLine2) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._recommend) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._available) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._billAddress) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._taxCodeOrIDCardTypeEnum) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._taxCodeOrIDCard) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._addressExt) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._phoneNumberCollected) }()
        case 22: try { try decoder.decodeRepeatedStringField(value: &_storage._shippingAddressErrors) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._customersID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customersID, fieldNumber: 2)
      }
      if !_storage._firstName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstName, fieldNumber: 3)
      }
      if !_storage._lastName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastName, fieldNumber: 4)
      }
      if !_storage._areaCodePhoneNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._areaCodePhoneNumber, fieldNumber: 5)
      }
      if !_storage._phoneNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._phoneNumber, fieldNumber: 6)
      }
      if !_storage._areaCodePhoneNumber2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._areaCodePhoneNumber2, fieldNumber: 7)
      }
      if !_storage._phoneNumber2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._phoneNumber2, fieldNumber: 8)
      }
      if let v = _storage._country {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._stateProvinceRegion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._postCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._postCode, fieldNumber: 11)
      }
      if let v = _storage._city {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._addressLine1.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addressLine1, fieldNumber: 13)
      }
      if !_storage._addressLine2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._addressLine2, fieldNumber: 14)
      }
      if _storage._recommend != false {
        try visitor.visitSingularBoolField(value: _storage._recommend, fieldNumber: 15)
      }
      if _storage._available != false {
        try visitor.visitSingularBoolField(value: _storage._available, fieldNumber: 16)
      }
      if _storage._billAddress != false {
        try visitor.visitSingularBoolField(value: _storage._billAddress, fieldNumber: 17)
      }
      if _storage._taxCodeOrIDCardTypeEnum != .unknown {
        try visitor.visitSingularEnumField(value: _storage._taxCodeOrIDCardTypeEnum, fieldNumber: 18)
      }
      if !_storage._taxCodeOrIDCard.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taxCodeOrIDCard, fieldNumber: 19)
      }
      if let v = _storage._addressExt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if _storage._phoneNumberCollected != false {
        try visitor.visitSingularBoolField(value: _storage._phoneNumberCollected, fieldNumber: 21)
      }
      if !_storage._shippingAddressErrors.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._shippingAddressErrors, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_Address, rhs: Address_Address) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._customersID != rhs_storage._customersID {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._areaCodePhoneNumber != rhs_storage._areaCodePhoneNumber {return false}
        if _storage._phoneNumber != rhs_storage._phoneNumber {return false}
        if _storage._areaCodePhoneNumber2 != rhs_storage._areaCodePhoneNumber2 {return false}
        if _storage._phoneNumber2 != rhs_storage._phoneNumber2 {return false}
        if _storage._country != rhs_storage._country {return false}
        if _storage._stateProvinceRegion != rhs_storage._stateProvinceRegion {return false}
        if _storage._postCode != rhs_storage._postCode {return false}
        if _storage._city != rhs_storage._city {return false}
        if _storage._addressLine1 != rhs_storage._addressLine1 {return false}
        if _storage._addressLine2 != rhs_storage._addressLine2 {return false}
        if _storage._recommend != rhs_storage._recommend {return false}
        if _storage._available != rhs_storage._available {return false}
        if _storage._billAddress != rhs_storage._billAddress {return false}
        if _storage._taxCodeOrIDCardTypeEnum != rhs_storage._taxCodeOrIDCardTypeEnum {return false}
        if _storage._taxCodeOrIDCard != rhs_storage._taxCodeOrIDCard {return false}
        if _storage._addressExt != rhs_storage._addressExt {return false}
        if _storage._phoneNumberCollected != rhs_storage._phoneNumberCollected {return false}
        if _storage._shippingAddressErrors != rhs_storage._shippingAddressErrors {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_AddressExt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressExt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "email"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.email) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_AddressExt, rhs: Address_AddressExt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.email != rhs.email {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetAddressListForAddressBookReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAddressListForAddressBookReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetAddressListForAddressBookReq, rhs: Address_GetAddressListForAddressBookReq) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetAddressListForAddressBookFakeResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAddressListForAddressBookFakeResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetAddressListForAddressBookFakeResp, rhs: Address_GetAddressListForAddressBookFakeResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetAddressDetailReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAddressDetailReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetAddressDetailReq, rhs: Address_GetAddressDetailReq) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetAddressDetailFakeResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAddressDetailFakeResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetAddressDetailFakeResp, rhs: Address_GetAddressDetailFakeResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetBillingAddressDetailReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBillingAddressDetailReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt32Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetBillingAddressDetailReq, rhs: Address_GetBillingAddressDetailReq) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetBillingAddressDetailFakeResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBillingAddressDetailFakeResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetBillingAddressDetailFakeResp, rhs: Address_GetBillingAddressDetailFakeResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_AddAddressReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAddressReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_AddAddressReq, rhs: Address_AddAddressReq) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_AddAddressFakeResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAddressFakeResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.data != 0 {
      try visitor.visitSingularInt32Field(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_AddAddressFakeResp, rhs: Address_AddAddressFakeResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_EditAddressReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditAddressReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_EditAddressReq, rhs: Address_EditAddressReq) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_EditAddressFakeResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditAddressFakeResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.data != 0 {
      try visitor.visitSingularInt32Field(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_EditAddressFakeResp, rhs: Address_EditAddressFakeResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_ModifyBillingAddressWithOrderReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModifyBillingAddressWithOrderReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "orderId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.orderID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.orderID != 0 {
      try visitor.visitSingularInt32Field(value: self.orderID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_ModifyBillingAddressWithOrderReq, rhs: Address_ModifyBillingAddressWithOrderReq) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.orderID != rhs.orderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_ModifyBillingAddressWithOrderFakeResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModifyBillingAddressWithOrderFakeResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.data != 0 {
      try visitor.visitSingularInt32Field(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_ModifyBillingAddressWithOrderFakeResp, rhs: Address_ModifyBillingAddressWithOrderFakeResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetCountryCascadeInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCountryCascadeInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countryId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.countryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.countryID != 0 {
      try visitor.visitSingularInt32Field(value: self.countryID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetCountryCascadeInfoReq, rhs: Address_GetCountryCascadeInfoReq) -> Bool {
    if lhs.countryID != rhs.countryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_GetCountryCascadeInfoFakeResp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCountryCascadeInfoFakeResp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_GetCountryCascadeInfoFakeResp, rhs: Address_GetCountryCascadeInfoFakeResp) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_CountryCascadeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountryCascadeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phoneNumberRegexList"),
    2: .same(proto: "postCodeRegexList"),
    3: .same(proto: "stateList"),
    4: .same(proto: "postcodeRegexTemplate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.phoneNumberRegexList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.postCodeRegexList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.stateList) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._postcodeRegexTemplate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phoneNumberRegexList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.phoneNumberRegexList, fieldNumber: 1)
    }
    if !self.postCodeRegexList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.postCodeRegexList, fieldNumber: 2)
    }
    if !self.stateList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stateList, fieldNumber: 3)
    }
    if let v = self._postcodeRegexTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_CountryCascadeInfo, rhs: Address_CountryCascadeInfo) -> Bool {
    if lhs.phoneNumberRegexList != rhs.phoneNumberRegexList {return false}
    if lhs.postCodeRegexList != rhs.postCodeRegexList {return false}
    if lhs.stateList != rhs.stateList {return false}
    if lhs._postcodeRegexTemplate != rhs._postcodeRegexTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_PostCodeOrPhoneNumberRegex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostCodeOrPhoneNumberRegex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countryId"),
    2: .same(proto: "regexId"),
    3: .same(proto: "regex"),
    4: .same(proto: "tip"),
    5: .same(proto: "strongCheck"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.countryID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.regexID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.regex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tip) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.strongCheck) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.countryID != 0 {
      try visitor.visitSingularInt32Field(value: self.countryID, fieldNumber: 1)
    }
    if self.regexID != 0 {
      try visitor.visitSingularInt32Field(value: self.regexID, fieldNumber: 2)
    }
    if !self.regex.isEmpty {
      try visitor.visitSingularStringField(value: self.regex, fieldNumber: 3)
    }
    if !self.tip.isEmpty {
      try visitor.visitSingularStringField(value: self.tip, fieldNumber: 4)
    }
    if self.strongCheck != false {
      try visitor.visitSingularBoolField(value: self.strongCheck, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_PostCodeOrPhoneNumberRegex, rhs: Address_PostCodeOrPhoneNumberRegex) -> Bool {
    if lhs.countryID != rhs.countryID {return false}
    if lhs.regexID != rhs.regexID {return false}
    if lhs.regex != rhs.regex {return false}
    if lhs.tip != rhs.tip {return false}
    if lhs.strongCheck != rhs.strongCheck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_StateProvinceRegion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateProvinceRegion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stateId"),
    2: .same(proto: "stateCode"),
    3: .same(proto: "countryId"),
    4: .same(proto: "stateName"),
    5: .same(proto: "cityList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.stateID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stateCode) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.countryID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.stateName) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.cityList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stateID != 0 {
      try visitor.visitSingularInt32Field(value: self.stateID, fieldNumber: 1)
    }
    if !self.stateCode.isEmpty {
      try visitor.visitSingularStringField(value: self.stateCode, fieldNumber: 2)
    }
    if self.countryID != 0 {
      try visitor.visitSingularInt32Field(value: self.countryID, fieldNumber: 3)
    }
    if !self.stateName.isEmpty {
      try visitor.visitSingularStringField(value: self.stateName, fieldNumber: 4)
    }
    if !self.cityList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cityList, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_StateProvinceRegion, rhs: Address_StateProvinceRegion) -> Bool {
    if lhs.stateID != rhs.stateID {return false}
    if lhs.stateCode != rhs.stateCode {return false}
    if lhs.countryID != rhs.countryID {return false}
    if lhs.stateName != rhs.stateName {return false}
    if lhs.cityList != rhs.cityList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_City: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".City"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    12: .same(proto: "cityId"),
    13: .same(proto: "cityName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.cityID) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.cityName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cityID != 0 {
      try visitor.visitSingularInt32Field(value: self.cityID, fieldNumber: 12)
    }
    if !self.cityName.isEmpty {
      try visitor.visitSingularStringField(value: self.cityName, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_City, rhs: Address_City) -> Bool {
    if lhs.cityID != rhs.cityID {return false}
    if lhs.cityName != rhs.cityName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Address_PostcodeRegexTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostcodeRegexTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "regex"),
    2: .same(proto: "template"),
    3: .same(proto: "replaceRegex"),
    4: .same(proto: "replacement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.regex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.template) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.replaceRegex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.replacement) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regex.isEmpty {
      try visitor.visitSingularStringField(value: self.regex, fieldNumber: 1)
    }
    if !self.template.isEmpty {
      try visitor.visitSingularStringField(value: self.template, fieldNumber: 2)
    }
    if !self.replaceRegex.isEmpty {
      try visitor.visitSingularStringField(value: self.replaceRegex, fieldNumber: 3)
    }
    if !self.replacement.isEmpty {
      try visitor.visitSingularStringField(value: self.replacement, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Address_PostcodeRegexTemplate, rhs: Address_PostcodeRegexTemplate) -> Bool {
    if lhs.regex != rhs.regex {return false}
    if lhs.template != rhs.template {return false}
    if lhs.replaceRegex != rhs.replaceRegex {return false}
    if lhs.replacement != rhs.replacement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
