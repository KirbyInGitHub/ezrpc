// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: usermsgcenter/customer_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// from Common.proto
public enum GETServiceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case other // = 0
  case buy4Me // = 1
  case ship4Me // = 2
  case ezbuy // = 3
  case prime // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .other
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .other
    case 1: self = .buy4Me
    case 2: self = .ship4Me
    case 3: self = .ezbuy
    case 4: self = .prime
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .other: return 0
    case .buy4Me: return 1
    case .ship4Me: return 2
    case .ezbuy: return 3
    case .prime: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GETServiceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [GETServiceType] = [
    .other,
    .buy4Me,
    .ship4Me,
    .ezbuy,
    .prime,
  ]
}

#endif  // swift(>=4.2)

public enum GETMessageType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case normal // = 0
  case orderPending // = 1
  case orderArrived // = 2
  case parcelArrangeable // = 3
  case enquiry // = 4
  case web // = 5
  case parcelPending // = 6
  case firebaseCallback // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .normal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .orderPending
    case 2: self = .orderArrived
    case 3: self = .parcelArrangeable
    case 4: self = .enquiry
    case 5: self = .web
    case 6: self = .parcelPending
    case 7: self = .firebaseCallback
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .normal: return 0
    case .orderPending: return 1
    case .orderArrived: return 2
    case .parcelArrangeable: return 3
    case .enquiry: return 4
    case .web: return 5
    case .parcelPending: return 6
    case .firebaseCallback: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension GETMessageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [GETMessageType] = [
    .normal,
    .orderPending,
    .orderArrived,
    .parcelArrangeable,
    .enquiry,
    .web,
    .parcelPending,
    .firebaseCallback,
  ]
}

#endif  // swift(>=4.2)

/// from ReadyToShip.proto
public struct GETReadyToShipGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var itemsCount: Int32 = 0

  public var serviceType: GETServiceType = .other

  public var warehouseCode: String = String()

  public var shippingMethodCode: String = String()

  public var shippingMethodName: String = String()

  public var itemsPics: [String] = []

  public var status: String = String()

  public var freeStorageDays: Int32 = 0

  public var chargedStorageDays: Int32 = 0

  public var storageFee: Double = 0

  public var notArrivedItemCount: Int32 = 0

  public var shippingMethodID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GETMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var messageType: String {
    get {return _storage._messageType}
    set {_uniqueStorage()._messageType = newValue}
  }

  public var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  public var isRead: Bool {
    get {return _storage._isRead}
    set {_uniqueStorage()._isRead = newValue}
  }

  public var orderID: Int32 {
    get {return _storage._orderID}
    set {_uniqueStorage()._orderID = newValue}
  }

  public var packageID: Int32 {
    get {return _storage._packageID}
    set {_uniqueStorage()._packageID = newValue}
  }

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var updateDate: String {
    get {return _storage._updateDate}
    set {_uniqueStorage()._updateDate = newValue}
  }

  public var type: GETMessageType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var readyToShipGroup: GETReadyToShipGroup {
    get {return _storage._readyToShipGroup ?? GETReadyToShipGroup()}
    set {_uniqueStorage()._readyToShipGroup = newValue}
  }
  /// Returns true if `readyToShipGroup` has been explicitly set.
  public var hasReadyToShipGroup: Bool {return _storage._readyToShipGroup != nil}
  /// Clears the value of `readyToShipGroup`. Subsequent reads from it will return its default value.
  public mutating func clearReadyToShipGroup() {_uniqueStorage()._readyToShipGroup = nil}

  /// 新订单号
  public var newOrderID: Int64 {
    get {return _storage._newOrderID}
    set {_uniqueStorage()._newOrderID = newValue}
  }

  /// 二级包裹号
  public var subPackageNumber: String {
    get {return _storage._subPackageNumber}
    set {_uniqueStorage()._subPackageNumber = newValue}
  }

  public var actionType: String {
    get {return _storage._actionType}
    set {_uniqueStorage()._actionType = newValue}
  }

  public var detail: GEPendingReplyDetail {
    get {return _storage._detail ?? GEPendingReplyDetail()}
    set {_uniqueStorage()._detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return _storage._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {_uniqueStorage()._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct GEPendingReplyDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newOrderItemID: Int64 = 0

  public var serviceType: GETServiceType = .other

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserDeleteMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserGetMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var offset: Int32 = 0

  public var limit: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserGetUnreadMessageCountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserSetAllMessagesReadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserSetMessageReadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserSetMessagesReadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserDeleteMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserGetMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: [GETMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserGetUnreadMessageCountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserSetAllMessagesReadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserSetMessageReadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GEUserSetMessagesReadResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "usermsgcenter"

extension GETServiceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TServiceTypeOther"),
    1: .same(proto: "TServiceTypeBuy4Me"),
    2: .same(proto: "TServiceTypeShip4Me"),
    3: .same(proto: "TServiceTypeEzbuy"),
    4: .same(proto: "TServiceTypePrime"),
  ]
}

extension GETMessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TMessageTypeNormal"),
    1: .same(proto: "TMessageTypeOrderPending"),
    2: .same(proto: "TMessageTypeOrderArrived"),
    3: .same(proto: "TMessageTypeParcelArrangeable"),
    4: .same(proto: "TMessageTypeEnquiry"),
    5: .same(proto: "TMessageTypeWeb"),
    6: .same(proto: "TMessageTypeParcelPending"),
    7: .same(proto: "TMessageTypeFirebaseCallback"),
  ]
}

extension GETReadyToShipGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TReadyToShipGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "itemsCount"),
    2: .same(proto: "serviceType"),
    3: .same(proto: "warehouseCode"),
    4: .same(proto: "shippingMethodCode"),
    5: .same(proto: "shippingMethodName"),
    6: .same(proto: "itemsPics"),
    7: .same(proto: "status"),
    8: .same(proto: "freeStorageDays"),
    9: .same(proto: "chargedStorageDays"),
    10: .same(proto: "storageFee"),
    11: .same(proto: "notArrivedItemCount"),
    12: .same(proto: "shippingMethodId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.itemsCount) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.serviceType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.warehouseCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.shippingMethodCode) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.shippingMethodName) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.itemsPics) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.freeStorageDays) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.chargedStorageDays) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.storageFee) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.notArrivedItemCount) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.shippingMethodID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.itemsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.itemsCount, fieldNumber: 1)
    }
    if self.serviceType != .other {
      try visitor.visitSingularEnumField(value: self.serviceType, fieldNumber: 2)
    }
    if !self.warehouseCode.isEmpty {
      try visitor.visitSingularStringField(value: self.warehouseCode, fieldNumber: 3)
    }
    if !self.shippingMethodCode.isEmpty {
      try visitor.visitSingularStringField(value: self.shippingMethodCode, fieldNumber: 4)
    }
    if !self.shippingMethodName.isEmpty {
      try visitor.visitSingularStringField(value: self.shippingMethodName, fieldNumber: 5)
    }
    if !self.itemsPics.isEmpty {
      try visitor.visitRepeatedStringField(value: self.itemsPics, fieldNumber: 6)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 7)
    }
    if self.freeStorageDays != 0 {
      try visitor.visitSingularInt32Field(value: self.freeStorageDays, fieldNumber: 8)
    }
    if self.chargedStorageDays != 0 {
      try visitor.visitSingularInt32Field(value: self.chargedStorageDays, fieldNumber: 9)
    }
    if self.storageFee != 0 {
      try visitor.visitSingularDoubleField(value: self.storageFee, fieldNumber: 10)
    }
    if self.notArrivedItemCount != 0 {
      try visitor.visitSingularInt32Field(value: self.notArrivedItemCount, fieldNumber: 11)
    }
    if self.shippingMethodID != 0 {
      try visitor.visitSingularInt64Field(value: self.shippingMethodID, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GETReadyToShipGroup, rhs: GETReadyToShipGroup) -> Bool {
    if lhs.itemsCount != rhs.itemsCount {return false}
    if lhs.serviceType != rhs.serviceType {return false}
    if lhs.warehouseCode != rhs.warehouseCode {return false}
    if lhs.shippingMethodCode != rhs.shippingMethodCode {return false}
    if lhs.shippingMethodName != rhs.shippingMethodName {return false}
    if lhs.itemsPics != rhs.itemsPics {return false}
    if lhs.status != rhs.status {return false}
    if lhs.freeStorageDays != rhs.freeStorageDays {return false}
    if lhs.chargedStorageDays != rhs.chargedStorageDays {return false}
    if lhs.storageFee != rhs.storageFee {return false}
    if lhs.notArrivedItemCount != rhs.notArrivedItemCount {return false}
    if lhs.shippingMethodID != rhs.shippingMethodID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GETMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "messageType"),
    3: .same(proto: "message"),
    4: .same(proto: "isRead"),
    5: .same(proto: "orderId"),
    6: .same(proto: "packageId"),
    7: .same(proto: "url"),
    8: .same(proto: "updateDate"),
    9: .same(proto: "type"),
    10: .same(proto: "readyToShipGroup"),
    11: .same(proto: "newOrderId"),
    12: .same(proto: "subPackageNumber"),
    13: .same(proto: "actionType"),
    14: .same(proto: "detail"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _messageType: String = String()
    var _message: String = String()
    var _isRead: Bool = false
    var _orderID: Int32 = 0
    var _packageID: Int32 = 0
    var _url: String = String()
    var _updateDate: String = String()
    var _type: GETMessageType = .normal
    var _readyToShipGroup: GETReadyToShipGroup? = nil
    var _newOrderID: Int64 = 0
    var _subPackageNumber: String = String()
    var _actionType: String = String()
    var _detail: GEPendingReplyDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _messageType = source._messageType
      _message = source._message
      _isRead = source._isRead
      _orderID = source._orderID
      _packageID = source._packageID
      _url = source._url
      _updateDate = source._updateDate
      _type = source._type
      _readyToShipGroup = source._readyToShipGroup
      _newOrderID = source._newOrderID
      _subPackageNumber = source._subPackageNumber
      _actionType = source._actionType
      _detail = source._detail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._messageType) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isRead) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._orderID) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._packageID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._updateDate) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._readyToShipGroup) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._newOrderID) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._subPackageNumber) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._actionType) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._detail) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._messageType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageType, fieldNumber: 2)
      }
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 3)
      }
      if _storage._isRead != false {
        try visitor.visitSingularBoolField(value: _storage._isRead, fieldNumber: 4)
      }
      if _storage._orderID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._orderID, fieldNumber: 5)
      }
      if _storage._packageID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._packageID, fieldNumber: 6)
      }
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 7)
      }
      if !_storage._updateDate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updateDate, fieldNumber: 8)
      }
      if _storage._type != .normal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 9)
      }
      if let v = _storage._readyToShipGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._newOrderID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._newOrderID, fieldNumber: 11)
      }
      if !_storage._subPackageNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subPackageNumber, fieldNumber: 12)
      }
      if !_storage._actionType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actionType, fieldNumber: 13)
      }
      if let v = _storage._detail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GETMessage, rhs: GETMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._messageType != rhs_storage._messageType {return false}
        if _storage._message != rhs_storage._message {return false}
        if _storage._isRead != rhs_storage._isRead {return false}
        if _storage._orderID != rhs_storage._orderID {return false}
        if _storage._packageID != rhs_storage._packageID {return false}
        if _storage._url != rhs_storage._url {return false}
        if _storage._updateDate != rhs_storage._updateDate {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._readyToShipGroup != rhs_storage._readyToShipGroup {return false}
        if _storage._newOrderID != rhs_storage._newOrderID {return false}
        if _storage._subPackageNumber != rhs_storage._subPackageNumber {return false}
        if _storage._actionType != rhs_storage._actionType {return false}
        if _storage._detail != rhs_storage._detail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEPendingReplyDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendingReplyDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newOrderItemId"),
    2: .same(proto: "ServiceType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.newOrderItemID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.serviceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.newOrderItemID != 0 {
      try visitor.visitSingularInt64Field(value: self.newOrderItemID, fieldNumber: 1)
    }
    if self.serviceType != .other {
      try visitor.visitSingularEnumField(value: self.serviceType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEPendingReplyDetail, rhs: GEPendingReplyDetail) -> Bool {
    if lhs.newOrderItemID != rhs.newOrderItemID {return false}
    if lhs.serviceType != rhs.serviceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserDeleteMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDeleteMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageIDs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.messageIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.messageIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserDeleteMessagesRequest, rhs: GEUserDeleteMessagesRequest) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserGetMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGetMessagesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt32Field(value: self.limit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserGetMessagesRequest, rhs: GEUserGetMessagesRequest) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserGetUnreadMessageCountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGetUnreadMessageCountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserGetUnreadMessageCountRequest, rhs: GEUserGetUnreadMessageCountRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserSetAllMessagesReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSetAllMessagesReadRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserSetAllMessagesReadRequest, rhs: GEUserSetAllMessagesReadRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserSetMessageReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSetMessageReadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularInt32Field(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserSetMessageReadRequest, rhs: GEUserSetMessageReadRequest) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserSetMessagesReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSetMessagesReadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageIDs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.messageIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.messageIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserSetMessagesReadRequest, rhs: GEUserSetMessagesReadRequest) -> Bool {
    if lhs.messageIds != rhs.messageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserDeleteMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDeleteMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserDeleteMessagesResponse, rhs: GEUserDeleteMessagesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserGetMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGetMessagesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserGetMessagesResponse, rhs: GEUserGetMessagesResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserGetUnreadMessageCountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGetUnreadMessageCountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != 0 {
      try visitor.visitSingularInt32Field(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserGetUnreadMessageCountResponse, rhs: GEUserGetUnreadMessageCountResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserSetAllMessagesReadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSetAllMessagesReadResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserSetAllMessagesReadResponse, rhs: GEUserSetAllMessagesReadResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserSetMessageReadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSetMessageReadResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserSetMessageReadResponse, rhs: GEUserSetMessageReadResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GEUserSetMessagesReadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSetMessagesReadResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GEUserSetMessagesReadResponse, rhs: GEUserSetMessagesReadResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
